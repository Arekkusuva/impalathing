// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package beeswax

import (
	"bytes"
	"fmt"
	"git.apache.org/thrift.git/lib/go/thrift"
	"github.com/koblas/impalathing/services/hive_metastore"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

var _ = hive_metastore.GoUnusedProtection__

type BeeswaxService interface {
	// Submit a query and return a handle (QueryHandle). The query runs asynchronously.
	//
	// Parameters:
	//  - Query
	Query(query *Query) (r *QueryHandle, err error)
	// run a query synchronously and return a handle (QueryHandle).
	//
	// Parameters:
	//  - Query
	//  - ClientCtx
	ExecuteAndWait(query *Query, clientCtx LogContextId) (r *QueryHandle, err error)
	// Get the query plan for a query.
	//
	// Parameters:
	//  - Query
	Explain(query *Query) (r *QueryExplanation, err error)
	// Get the results of a query. This is non-blocking. Caller should check
	// Results.ready to determine if the results are in yet. The call requests
	// the batch size of fetch.
	//
	// Parameters:
	//  - QueryId
	//  - StartOver
	//  - FetchSize
	Fetch(query_id *QueryHandle, start_over bool, fetch_size int32) (r *Results, err error)
	// Get the state of the query
	//
	// Parameters:
	//  - Handle
	GetState(handle *QueryHandle) (r QueryState, err error)
	// Get the result metadata
	//
	// Parameters:
	//  - Handle
	GetResultsMetadata(handle *QueryHandle) (r *ResultsMetadata, err error)
	// Used to test connection to server.  A "noop" command.
	//
	// Parameters:
	//  - S
	Echo(s string) (r string, err error)
	// Returns a string representation of the configuration object being used.
	// Handy for debugging.
	DumpConfig() (r string, err error)
	// Get the log messages related to the given context.
	//
	// Parameters:
	//  - Context
	GetLog(context LogContextId) (r string, err error)
	// Parameters:
	//  - IncludeHadoop
	GetDefaultConfiguration(include_hadoop bool) (r []*ConfigVariable, err error)
	// Parameters:
	//  - Handle
	Close(handle *QueryHandle) (err error)
	// Parameters:
	//  - LogContext
	Clean(log_context LogContextId) (err error)
}

type BeeswaxServiceClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewBeeswaxServiceClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *BeeswaxServiceClient {
	return &BeeswaxServiceClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewBeeswaxServiceClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *BeeswaxServiceClient {
	return &BeeswaxServiceClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Submit a query and return a handle (QueryHandle). The query runs asynchronously.
//
// Parameters:
//  - Query
func (p *BeeswaxServiceClient) Query(query *Query) (r *QueryHandle, err error) {
	if err = p.sendQuery(query); err != nil {
		return
	}
	return p.recvQuery()
}

func (p *BeeswaxServiceClient) sendQuery(query *Query) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("query", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := QueryArgs{
		Query: query,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvQuery() (value *QueryHandle, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error3 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error4 error
		error4, err = error3.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error4
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "query failed: out of sequence response")
		return
	}
	result := QueryResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// run a query synchronously and return a handle (QueryHandle).
//
// Parameters:
//  - Query
//  - ClientCtx
func (p *BeeswaxServiceClient) ExecuteAndWait(query *Query, clientCtx LogContextId) (r *QueryHandle, err error) {
	if err = p.sendExecuteAndWait(query, clientCtx); err != nil {
		return
	}
	return p.recvExecuteAndWait()
}

func (p *BeeswaxServiceClient) sendExecuteAndWait(query *Query, clientCtx LogContextId) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("executeAndWait", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExecuteAndWaitArgs{
		Query:     query,
		ClientCtx: clientCtx,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvExecuteAndWait() (value *QueryHandle, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error6 error
		error6, err = error5.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error6
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "executeAndWait failed: out of sequence response")
		return
	}
	result := ExecuteAndWaitResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Get the query plan for a query.
//
// Parameters:
//  - Query
func (p *BeeswaxServiceClient) Explain(query *Query) (r *QueryExplanation, err error) {
	if err = p.sendExplain(query); err != nil {
		return
	}
	return p.recvExplain()
}

func (p *BeeswaxServiceClient) sendExplain(query *Query) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("explain", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ExplainArgs{
		Query: query,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvExplain() (value *QueryExplanation, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error7 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error8 error
		error8, err = error7.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error8
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "explain failed: out of sequence response")
		return
	}
	result := ExplainResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Get the results of a query. This is non-blocking. Caller should check
// Results.ready to determine if the results are in yet. The call requests
// the batch size of fetch.
//
// Parameters:
//  - QueryId
//  - StartOver
//  - FetchSize
func (p *BeeswaxServiceClient) Fetch(query_id *QueryHandle, start_over bool, fetch_size int32) (r *Results, err error) {
	if err = p.sendFetch(query_id, start_over, fetch_size); err != nil {
		return
	}
	return p.recvFetch()
}

func (p *BeeswaxServiceClient) sendFetch(query_id *QueryHandle, start_over bool, fetch_size int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("fetch", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := FetchArgs{
		QueryId:   query_id,
		StartOver: start_over,
		FetchSize: fetch_size,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvFetch() (value *Results, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error9 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error10 error
		error10, err = error9.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error10
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "fetch failed: out of sequence response")
		return
	}
	result := FetchResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	} else if result.Error2 != nil {
		err = result.Error2
		return
	}
	value = result.GetSuccess()
	return
}

// Get the state of the query
//
// Parameters:
//  - Handle
func (p *BeeswaxServiceClient) GetState(handle *QueryHandle) (r QueryState, err error) {
	if err = p.sendGetState(handle); err != nil {
		return
	}
	return p.recvGetState()
}

func (p *BeeswaxServiceClient) sendGetState(handle *QueryHandle) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_state", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetStateArgs{
		Handle: handle,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvGetState() (value QueryState, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error11 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error12 error
		error12, err = error11.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error12
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_state failed: out of sequence response")
		return
	}
	result := GetStateResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Get the result metadata
//
// Parameters:
//  - Handle
func (p *BeeswaxServiceClient) GetResultsMetadata(handle *QueryHandle) (r *ResultsMetadata, err error) {
	if err = p.sendGetResultsMetadata(handle); err != nil {
		return
	}
	return p.recvGetResultsMetadata()
}

func (p *BeeswaxServiceClient) sendGetResultsMetadata(handle *QueryHandle) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_results_metadata", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetResultsMetadataArgs{
		Handle: handle,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvGetResultsMetadata() (value *ResultsMetadata, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error13 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error14 error
		error14, err = error13.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error14
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_results_metadata failed: out of sequence response")
		return
	}
	result := GetResultsMetadataResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Used to test connection to server.  A "noop" command.
//
// Parameters:
//  - S
func (p *BeeswaxServiceClient) Echo(s string) (r string, err error) {
	if err = p.sendEcho(s); err != nil {
		return
	}
	return p.recvEcho()
}

func (p *BeeswaxServiceClient) sendEcho(s string) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("echo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := EchoArgs{
		S: s,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvEcho() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error15 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error16 error
		error16, err = error15.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error16
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "echo failed: out of sequence response")
		return
	}
	result := EchoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Returns a string representation of the configuration object being used.
// Handy for debugging.
func (p *BeeswaxServiceClient) DumpConfig() (r string, err error) {
	if err = p.sendDumpConfig(); err != nil {
		return
	}
	return p.recvDumpConfig()
}

func (p *BeeswaxServiceClient) sendDumpConfig() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("dump_config", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DumpConfigArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvDumpConfig() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error17 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error18 error
		error18, err = error17.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error18
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "dump_config failed: out of sequence response")
		return
	}
	result := DumpConfigResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Get the log messages related to the given context.
//
// Parameters:
//  - Context
func (p *BeeswaxServiceClient) GetLog(context LogContextId) (r string, err error) {
	if err = p.sendGetLog(context); err != nil {
		return
	}
	return p.recvGetLog()
}

func (p *BeeswaxServiceClient) sendGetLog(context LogContextId) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_log", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetLogArgs{
		Context: context,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvGetLog() (value string, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error19 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error20 error
		error20, err = error19.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error20
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_log failed: out of sequence response")
		return
	}
	result := GetLogResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - IncludeHadoop
func (p *BeeswaxServiceClient) GetDefaultConfiguration(include_hadoop bool) (r []*ConfigVariable, err error) {
	if err = p.sendGetDefaultConfiguration(include_hadoop); err != nil {
		return
	}
	return p.recvGetDefaultConfiguration()
}

func (p *BeeswaxServiceClient) sendGetDefaultConfiguration(include_hadoop bool) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get_default_configuration", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetDefaultConfigurationArgs{
		IncludeHadoop: include_hadoop,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvGetDefaultConfiguration() (value []*ConfigVariable, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error21 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error22 error
		error22, err = error21.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error22
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get_default_configuration failed: out of sequence response")
		return
	}
	result := GetDefaultConfigurationResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - Handle
func (p *BeeswaxServiceClient) Close(handle *QueryHandle) (err error) {
	if err = p.sendClose(handle); err != nil {
		return
	}
	return p.recvClose()
}

func (p *BeeswaxServiceClient) sendClose(handle *QueryHandle) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("close", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CloseArgs{
		Handle: handle,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvClose() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error23 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error24 error
		error24, err = error23.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error24
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "close failed: out of sequence response")
		return
	}
	result := CloseResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.ErrorA1 != nil {
		err = result.ErrorA1
		return
	} else if result.Error2 != nil {
		err = result.Error2
		return
	}
	return
}

// Parameters:
//  - LogContext
func (p *BeeswaxServiceClient) Clean(log_context LogContextId) (err error) {
	if err = p.sendClean(log_context); err != nil {
		return
	}
	return p.recvClean()
}

func (p *BeeswaxServiceClient) sendClean(log_context LogContextId) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("clean", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CleanArgs{
		LogContext: log_context,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush()
}

func (p *BeeswaxServiceClient) recvClean() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error25 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		var error26 error
		error26, err = error25.Read(iprot)
		if err != nil {
			return
		}
		if err = iprot.ReadMessageEnd(); err != nil {
			return
		}
		err = error26
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "clean failed: out of sequence response")
		return
	}
	result := CleanResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	return
}

type BeeswaxServiceProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      BeeswaxService
}

func (p *BeeswaxServiceProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *BeeswaxServiceProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *BeeswaxServiceProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewBeeswaxServiceProcessor(handler BeeswaxService) *BeeswaxServiceProcessor {

	self27 := &BeeswaxServiceProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self27.processorMap["query"] = &beeswaxServiceProcessorQuery{handler: handler}
	self27.processorMap["executeAndWait"] = &beeswaxServiceProcessorExecuteAndWait{handler: handler}
	self27.processorMap["explain"] = &beeswaxServiceProcessorExplain{handler: handler}
	self27.processorMap["fetch"] = &beeswaxServiceProcessorFetch{handler: handler}
	self27.processorMap["get_state"] = &beeswaxServiceProcessorGetState{handler: handler}
	self27.processorMap["get_results_metadata"] = &beeswaxServiceProcessorGetResultsMetadata{handler: handler}
	self27.processorMap["echo"] = &beeswaxServiceProcessorEcho{handler: handler}
	self27.processorMap["dump_config"] = &beeswaxServiceProcessorDumpConfig{handler: handler}
	self27.processorMap["get_log"] = &beeswaxServiceProcessorGetLog{handler: handler}
	self27.processorMap["get_default_configuration"] = &beeswaxServiceProcessorGetDefaultConfiguration{handler: handler}
	self27.processorMap["close"] = &beeswaxServiceProcessorClose{handler: handler}
	self27.processorMap["clean"] = &beeswaxServiceProcessorClean{handler: handler}
	return self27
}

func (p *BeeswaxServiceProcessor) Process(iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x28 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x28.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush()
	return false, x28

}

type beeswaxServiceProcessorQuery struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorQuery) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := QueryArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("query", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := QueryResult{}
	var retval *QueryHandle
	var err2 error
	if retval, err2 = p.handler.Query(args.Query); err2 != nil {
		switch v := err2.(type) {
		case *BeeswaxException:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing query: "+err2.Error())
			oprot.WriteMessageBegin("query", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("query", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorExecuteAndWait struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorExecuteAndWait) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExecuteAndWaitArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("executeAndWait", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExecuteAndWaitResult{}
	var retval *QueryHandle
	var err2 error
	if retval, err2 = p.handler.ExecuteAndWait(args.Query, args.ClientCtx); err2 != nil {
		switch v := err2.(type) {
		case *BeeswaxException:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing executeAndWait: "+err2.Error())
			oprot.WriteMessageBegin("executeAndWait", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("executeAndWait", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorExplain struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorExplain) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ExplainArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("explain", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ExplainResult{}
	var retval *QueryExplanation
	var err2 error
	if retval, err2 = p.handler.Explain(args.Query); err2 != nil {
		switch v := err2.(type) {
		case *BeeswaxException:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing explain: "+err2.Error())
			oprot.WriteMessageBegin("explain", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("explain", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorFetch struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorFetch) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := FetchArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("fetch", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := FetchResult{}
	var retval *Results
	var err2 error
	if retval, err2 = p.handler.Fetch(args.QueryId, args.StartOver, args.FetchSize); err2 != nil {
		switch v := err2.(type) {
		case *QueryNotFoundException:
			result.ErrorA1 = v
		case *BeeswaxException:
			result.Error2 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing fetch: "+err2.Error())
			oprot.WriteMessageBegin("fetch", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("fetch", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorGetState struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorGetState) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetStateArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_state", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetStateResult{}
	var retval QueryState
	var err2 error
	if retval, err2 = p.handler.GetState(args.Handle); err2 != nil {
		switch v := err2.(type) {
		case *QueryNotFoundException:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_state: "+err2.Error())
			oprot.WriteMessageBegin("get_state", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("get_state", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorGetResultsMetadata struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorGetResultsMetadata) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetResultsMetadataArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_results_metadata", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResultsMetadataResult{}
	var retval *ResultsMetadata
	var err2 error
	if retval, err2 = p.handler.GetResultsMetadata(args.Handle); err2 != nil {
		switch v := err2.(type) {
		case *QueryNotFoundException:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_results_metadata: "+err2.Error())
			oprot.WriteMessageBegin("get_results_metadata", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get_results_metadata", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorEcho struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorEcho) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := EchoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("echo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := EchoResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.Echo(args.S); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing echo: "+err2.Error())
		oprot.WriteMessageBegin("echo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("echo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorDumpConfig struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorDumpConfig) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DumpConfigArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("dump_config", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DumpConfigResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.DumpConfig(); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing dump_config: "+err2.Error())
		oprot.WriteMessageBegin("dump_config", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("dump_config", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorGetLog struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorGetLog) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetLogArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_log", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetLogResult{}
	var retval string
	var err2 error
	if retval, err2 = p.handler.GetLog(args.Context); err2 != nil {
		switch v := err2.(type) {
		case *QueryNotFoundException:
			result.ErrorA1 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_log: "+err2.Error())
			oprot.WriteMessageBegin("get_log", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("get_log", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorGetDefaultConfiguration struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorGetDefaultConfiguration) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetDefaultConfigurationArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get_default_configuration", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetDefaultConfigurationResult{}
	var retval []*ConfigVariable
	var err2 error
	if retval, err2 = p.handler.GetDefaultConfiguration(args.IncludeHadoop); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get_default_configuration: "+err2.Error())
		oprot.WriteMessageBegin("get_default_configuration", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get_default_configuration", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorClose struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorClose) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CloseArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("close", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CloseResult{}
	var err2 error
	if err2 = p.handler.Close(args.Handle); err2 != nil {
		switch v := err2.(type) {
		case *QueryNotFoundException:
			result.ErrorA1 = v
		case *BeeswaxException:
			result.Error2 = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing close: "+err2.Error())
			oprot.WriteMessageBegin("close", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush()
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("close", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type beeswaxServiceProcessorClean struct {
	handler BeeswaxService
}

func (p *beeswaxServiceProcessorClean) Process(seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CleanArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("clean", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CleanResult{}
	var err2 error
	if err2 = p.handler.Clean(args.LogContext); err2 != nil {
		x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing clean: "+err2.Error())
		oprot.WriteMessageBegin("clean", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush()
		return true, err2
	}
	if err2 = oprot.WriteMessageBegin("clean", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type QueryArgs struct {
	Query *Query `thrift:"query,1" json:"query"`
}

func NewQueryArgs() *QueryArgs {
	return &QueryArgs{}
}

var QueryArgs_Query_DEFAULT *Query

func (p *QueryArgs) GetQuery() *Query {
	if !p.IsSetQuery() {
		return QueryArgs_Query_DEFAULT
	}
	return p.Query
}
func (p *QueryArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *QueryArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QueryArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Query = &Query{}
	if err := p.Query.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Query, err)
	}
	return nil
}

func (p *QueryArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("query_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QueryArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Query, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *QueryArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryArgs(%+v)", *p)
}

type QueryResult struct {
	Success *QueryHandle      `thrift:"success,0" json:"success"`
	ErrorA1 *BeeswaxException `thrift:"error,1" json:"error"`
}

func NewQueryResult() *QueryResult {
	return &QueryResult{}
}

var QueryResult_Success_DEFAULT *QueryHandle

func (p *QueryResult) GetSuccess() *QueryHandle {
	if !p.IsSetSuccess() {
		return QueryResult_Success_DEFAULT
	}
	return p.Success
}

var QueryResult_ErrorA1_DEFAULT *BeeswaxException

func (p *QueryResult) GetErrorA1() *BeeswaxException {
	if !p.IsSetErrorA1() {
		return QueryResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *QueryResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *QueryResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *QueryResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *QueryResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &QueryHandle{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *QueryResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &BeeswaxException{
		SQLState: "     ",
	}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *QueryResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("query_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *QueryResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *QueryResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *QueryResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("QueryResult(%+v)", *p)
}

type ExecuteAndWaitArgs struct {
	Query     *Query       `thrift:"query,1" json:"query"`
	ClientCtx LogContextId `thrift:"clientCtx,2" json:"clientCtx"`
}

func NewExecuteAndWaitArgs() *ExecuteAndWaitArgs {
	return &ExecuteAndWaitArgs{}
}

var ExecuteAndWaitArgs_Query_DEFAULT *Query

func (p *ExecuteAndWaitArgs) GetQuery() *Query {
	if !p.IsSetQuery() {
		return ExecuteAndWaitArgs_Query_DEFAULT
	}
	return p.Query
}

func (p *ExecuteAndWaitArgs) GetClientCtx() LogContextId {
	return p.ClientCtx
}
func (p *ExecuteAndWaitArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *ExecuteAndWaitArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteAndWaitArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Query = &Query{}
	if err := p.Query.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Query, err)
	}
	return nil
}

func (p *ExecuteAndWaitArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := LogContextId(v)
		p.ClientCtx = temp
	}
	return nil
}

func (p *ExecuteAndWaitArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("executeAndWait_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteAndWaitArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Query, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *ExecuteAndWaitArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("clientCtx", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:clientCtx: %s", p, err)
	}
	if err := oprot.WriteString(string(p.ClientCtx)); err != nil {
		return fmt.Errorf("%T.clientCtx (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:clientCtx: %s", p, err)
	}
	return err
}

func (p *ExecuteAndWaitArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteAndWaitArgs(%+v)", *p)
}

type ExecuteAndWaitResult struct {
	Success *QueryHandle      `thrift:"success,0" json:"success"`
	ErrorA1 *BeeswaxException `thrift:"error,1" json:"error"`
}

func NewExecuteAndWaitResult() *ExecuteAndWaitResult {
	return &ExecuteAndWaitResult{}
}

var ExecuteAndWaitResult_Success_DEFAULT *QueryHandle

func (p *ExecuteAndWaitResult) GetSuccess() *QueryHandle {
	if !p.IsSetSuccess() {
		return ExecuteAndWaitResult_Success_DEFAULT
	}
	return p.Success
}

var ExecuteAndWaitResult_ErrorA1_DEFAULT *BeeswaxException

func (p *ExecuteAndWaitResult) GetErrorA1() *BeeswaxException {
	if !p.IsSetErrorA1() {
		return ExecuteAndWaitResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *ExecuteAndWaitResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExecuteAndWaitResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *ExecuteAndWaitResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExecuteAndWaitResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &QueryHandle{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExecuteAndWaitResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &BeeswaxException{
		SQLState: "     ",
	}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *ExecuteAndWaitResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("executeAndWait_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExecuteAndWaitResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteAndWaitResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *ExecuteAndWaitResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExecuteAndWaitResult(%+v)", *p)
}

type ExplainArgs struct {
	Query *Query `thrift:"query,1" json:"query"`
}

func NewExplainArgs() *ExplainArgs {
	return &ExplainArgs{}
}

var ExplainArgs_Query_DEFAULT *Query

func (p *ExplainArgs) GetQuery() *Query {
	if !p.IsSetQuery() {
		return ExplainArgs_Query_DEFAULT
	}
	return p.Query
}
func (p *ExplainArgs) IsSetQuery() bool {
	return p.Query != nil
}

func (p *ExplainArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExplainArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Query = &Query{}
	if err := p.Query.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Query, err)
	}
	return nil
}

func (p *ExplainArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("explain_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExplainArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query: %s", p, err)
	}
	if err := p.Query.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Query, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query: %s", p, err)
	}
	return err
}

func (p *ExplainArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExplainArgs(%+v)", *p)
}

type ExplainResult struct {
	Success *QueryExplanation `thrift:"success,0" json:"success"`
	ErrorA1 *BeeswaxException `thrift:"error,1" json:"error"`
}

func NewExplainResult() *ExplainResult {
	return &ExplainResult{}
}

var ExplainResult_Success_DEFAULT *QueryExplanation

func (p *ExplainResult) GetSuccess() *QueryExplanation {
	if !p.IsSetSuccess() {
		return ExplainResult_Success_DEFAULT
	}
	return p.Success
}

var ExplainResult_ErrorA1_DEFAULT *BeeswaxException

func (p *ExplainResult) GetErrorA1() *BeeswaxException {
	if !p.IsSetErrorA1() {
		return ExplainResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *ExplainResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ExplainResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *ExplainResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ExplainResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &QueryExplanation{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *ExplainResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &BeeswaxException{
		SQLState: "     ",
	}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *ExplainResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("explain_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ExplainResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ExplainResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *ExplainResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ExplainResult(%+v)", *p)
}

type FetchArgs struct {
	QueryId   *QueryHandle `thrift:"query_id,1" json:"query_id"`
	StartOver bool         `thrift:"start_over,2" json:"start_over"`
	FetchSize int32        `thrift:"fetch_size,3" json:"fetch_size"`
}

func NewFetchArgs() *FetchArgs {
	return &FetchArgs{
		FetchSize: -1,
	}
}

var FetchArgs_QueryId_DEFAULT *QueryHandle

func (p *FetchArgs) GetQueryId() *QueryHandle {
	if !p.IsSetQueryId() {
		return FetchArgs_QueryId_DEFAULT
	}
	return p.QueryId
}

func (p *FetchArgs) GetStartOver() bool {
	return p.StartOver
}

func (p *FetchArgs) GetFetchSize() int32 {
	return p.FetchSize
}
func (p *FetchArgs) IsSetQueryId() bool {
	return p.QueryId != nil
}

func (p *FetchArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FetchArgs) ReadField1(iprot thrift.TProtocol) error {
	p.QueryId = &QueryHandle{}
	if err := p.QueryId.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.QueryId, err)
	}
	return nil
}

func (p *FetchArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.StartOver = v
	}
	return nil
}

func (p *FetchArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.FetchSize = v
	}
	return nil
}

func (p *FetchArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetch_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FetchArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("query_id", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:query_id: %s", p, err)
	}
	if err := p.QueryId.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.QueryId, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:query_id: %s", p, err)
	}
	return err
}

func (p *FetchArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("start_over", thrift.BOOL, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:start_over: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.StartOver)); err != nil {
		return fmt.Errorf("%T.start_over (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:start_over: %s", p, err)
	}
	return err
}

func (p *FetchArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("fetch_size", thrift.I32, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:fetch_size: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.FetchSize)); err != nil {
		return fmt.Errorf("%T.fetch_size (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:fetch_size: %s", p, err)
	}
	return err
}

func (p *FetchArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchArgs(%+v)", *p)
}

type FetchResult struct {
	Success *Results                `thrift:"success,0" json:"success"`
	ErrorA1 *QueryNotFoundException `thrift:"error,1" json:"error"`
	Error2  *BeeswaxException       `thrift:"error2,2" json:"error2"`
}

func NewFetchResult() *FetchResult {
	return &FetchResult{}
}

var FetchResult_Success_DEFAULT *Results

func (p *FetchResult) GetSuccess() *Results {
	if !p.IsSetSuccess() {
		return FetchResult_Success_DEFAULT
	}
	return p.Success
}

var FetchResult_ErrorA1_DEFAULT *QueryNotFoundException

func (p *FetchResult) GetErrorA1() *QueryNotFoundException {
	if !p.IsSetErrorA1() {
		return FetchResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}

var FetchResult_Error2_DEFAULT *BeeswaxException

func (p *FetchResult) GetError2() *BeeswaxException {
	if !p.IsSetError2() {
		return FetchResult_Error2_DEFAULT
	}
	return p.Error2
}
func (p *FetchResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *FetchResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *FetchResult) IsSetError2() bool {
	return p.Error2 != nil
}

func (p *FetchResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *FetchResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &Results{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *FetchResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &QueryNotFoundException{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *FetchResult) ReadField2(iprot thrift.TProtocol) error {
	p.Error2 = &BeeswaxException{
		SQLState: "     ",
	}
	if err := p.Error2.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Error2, err)
	}
	return nil
}

func (p *FetchResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("fetch_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *FetchResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *FetchResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *FetchResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetError2() {
		if err := oprot.WriteFieldBegin("error2", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:error2: %s", p, err)
		}
		if err := p.Error2.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Error2, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:error2: %s", p, err)
		}
	}
	return err
}

func (p *FetchResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("FetchResult(%+v)", *p)
}

type GetStateArgs struct {
	Handle *QueryHandle `thrift:"handle,1" json:"handle"`
}

func NewGetStateArgs() *GetStateArgs {
	return &GetStateArgs{}
}

var GetStateArgs_Handle_DEFAULT *QueryHandle

func (p *GetStateArgs) GetHandle() *QueryHandle {
	if !p.IsSetHandle() {
		return GetStateArgs_Handle_DEFAULT
	}
	return p.Handle
}
func (p *GetStateArgs) IsSetHandle() bool {
	return p.Handle != nil
}

func (p *GetStateArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetStateArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Handle = &QueryHandle{}
	if err := p.Handle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Handle, err)
	}
	return nil
}

func (p *GetStateArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_state_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetStateArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("handle", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:handle: %s", p, err)
	}
	if err := p.Handle.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Handle, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:handle: %s", p, err)
	}
	return err
}

func (p *GetStateArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetStateArgs(%+v)", *p)
}

type GetStateResult struct {
	Success *QueryState             `thrift:"success,0" json:"success"`
	ErrorA1 *QueryNotFoundException `thrift:"error,1" json:"error"`
}

func NewGetStateResult() *GetStateResult {
	return &GetStateResult{}
}

var GetStateResult_Success_DEFAULT QueryState

func (p *GetStateResult) GetSuccess() QueryState {
	if !p.IsSetSuccess() {
		return GetStateResult_Success_DEFAULT
	}
	return *p.Success
}

var GetStateResult_ErrorA1_DEFAULT *QueryNotFoundException

func (p *GetStateResult) GetErrorA1() *QueryNotFoundException {
	if !p.IsSetErrorA1() {
		return GetStateResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *GetStateResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetStateResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *GetStateResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetStateResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := QueryState(v)
		p.Success = &temp
	}
	return nil
}

func (p *GetStateResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &QueryNotFoundException{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *GetStateResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_state_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetStateResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetStateResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *GetStateResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetStateResult(%+v)", *p)
}

type GetResultsMetadataArgs struct {
	Handle *QueryHandle `thrift:"handle,1" json:"handle"`
}

func NewGetResultsMetadataArgs() *GetResultsMetadataArgs {
	return &GetResultsMetadataArgs{}
}

var GetResultsMetadataArgs_Handle_DEFAULT *QueryHandle

func (p *GetResultsMetadataArgs) GetHandle() *QueryHandle {
	if !p.IsSetHandle() {
		return GetResultsMetadataArgs_Handle_DEFAULT
	}
	return p.Handle
}
func (p *GetResultsMetadataArgs) IsSetHandle() bool {
	return p.Handle != nil
}

func (p *GetResultsMetadataArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResultsMetadataArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Handle = &QueryHandle{}
	if err := p.Handle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Handle, err)
	}
	return nil
}

func (p *GetResultsMetadataArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_results_metadata_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResultsMetadataArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("handle", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:handle: %s", p, err)
	}
	if err := p.Handle.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Handle, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:handle: %s", p, err)
	}
	return err
}

func (p *GetResultsMetadataArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResultsMetadataArgs(%+v)", *p)
}

type GetResultsMetadataResult struct {
	Success *ResultsMetadata        `thrift:"success,0" json:"success"`
	ErrorA1 *QueryNotFoundException `thrift:"error,1" json:"error"`
}

func NewGetResultsMetadataResult() *GetResultsMetadataResult {
	return &GetResultsMetadataResult{}
}

var GetResultsMetadataResult_Success_DEFAULT *ResultsMetadata

func (p *GetResultsMetadataResult) GetSuccess() *ResultsMetadata {
	if !p.IsSetSuccess() {
		return GetResultsMetadataResult_Success_DEFAULT
	}
	return p.Success
}

var GetResultsMetadataResult_ErrorA1_DEFAULT *QueryNotFoundException

func (p *GetResultsMetadataResult) GetErrorA1() *QueryNotFoundException {
	if !p.IsSetErrorA1() {
		return GetResultsMetadataResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *GetResultsMetadataResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResultsMetadataResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *GetResultsMetadataResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResultsMetadataResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &ResultsMetadata{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetResultsMetadataResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &QueryNotFoundException{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *GetResultsMetadataResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_results_metadata_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResultsMetadataResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResultsMetadataResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *GetResultsMetadataResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResultsMetadataResult(%+v)", *p)
}

type EchoArgs struct {
	S string `thrift:"s,1" json:"s"`
}

func NewEchoArgs() *EchoArgs {
	return &EchoArgs{}
}

func (p *EchoArgs) GetS() string {
	return p.S
}
func (p *EchoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EchoArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.S = v
	}
	return nil
}

func (p *EchoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("echo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EchoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("s", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:s: %s", p, err)
	}
	if err := oprot.WriteString(string(p.S)); err != nil {
		return fmt.Errorf("%T.s (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:s: %s", p, err)
	}
	return err
}

func (p *EchoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EchoArgs(%+v)", *p)
}

type EchoResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewEchoResult() *EchoResult {
	return &EchoResult{}
}

var EchoResult_Success_DEFAULT string

func (p *EchoResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return EchoResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *EchoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *EchoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EchoResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *EchoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("echo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EchoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *EchoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EchoResult(%+v)", *p)
}

type DumpConfigArgs struct {
}

func NewDumpConfigArgs() *DumpConfigArgs {
	return &DumpConfigArgs{}
}

func (p *DumpConfigArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DumpConfigArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("dump_config_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DumpConfigArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DumpConfigArgs(%+v)", *p)
}

type DumpConfigResult struct {
	Success *string `thrift:"success,0" json:"success"`
}

func NewDumpConfigResult() *DumpConfigResult {
	return &DumpConfigResult{}
}

var DumpConfigResult_Success_DEFAULT string

func (p *DumpConfigResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return DumpConfigResult_Success_DEFAULT
	}
	return *p.Success
}
func (p *DumpConfigResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *DumpConfigResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DumpConfigResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *DumpConfigResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("dump_config_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DumpConfigResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *DumpConfigResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DumpConfigResult(%+v)", *p)
}

type GetLogArgs struct {
	Context LogContextId `thrift:"context,1" json:"context"`
}

func NewGetLogArgs() *GetLogArgs {
	return &GetLogArgs{}
}

func (p *GetLogArgs) GetContext() LogContextId {
	return p.Context
}
func (p *GetLogArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLogArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := LogContextId(v)
		p.Context = temp
	}
	return nil
}

func (p *GetLogArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_log_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLogArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("context", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:context: %s", p, err)
	}
	if err := oprot.WriteString(string(p.Context)); err != nil {
		return fmt.Errorf("%T.context (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:context: %s", p, err)
	}
	return err
}

func (p *GetLogArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLogArgs(%+v)", *p)
}

type GetLogResult struct {
	Success *string                 `thrift:"success,0" json:"success"`
	ErrorA1 *QueryNotFoundException `thrift:"error,1" json:"error"`
}

func NewGetLogResult() *GetLogResult {
	return &GetLogResult{}
}

var GetLogResult_Success_DEFAULT string

func (p *GetLogResult) GetSuccess() string {
	if !p.IsSetSuccess() {
		return GetLogResult_Success_DEFAULT
	}
	return *p.Success
}

var GetLogResult_ErrorA1_DEFAULT *QueryNotFoundException

func (p *GetLogResult) GetErrorA1() *QueryNotFoundException {
	if !p.IsSetErrorA1() {
		return GetLogResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}
func (p *GetLogResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetLogResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *GetLogResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetLogResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *GetLogResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &QueryNotFoundException{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *GetLogResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_log_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetLogResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRING, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteString(string(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetLogResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *GetLogResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetLogResult(%+v)", *p)
}

type GetDefaultConfigurationArgs struct {
	IncludeHadoop bool `thrift:"include_hadoop,1" json:"include_hadoop"`
}

func NewGetDefaultConfigurationArgs() *GetDefaultConfigurationArgs {
	return &GetDefaultConfigurationArgs{}
}

func (p *GetDefaultConfigurationArgs) GetIncludeHadoop() bool {
	return p.IncludeHadoop
}
func (p *GetDefaultConfigurationArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDefaultConfigurationArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		p.IncludeHadoop = v
	}
	return nil
}

func (p *GetDefaultConfigurationArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_default_configuration_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDefaultConfigurationArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("include_hadoop", thrift.BOOL, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:include_hadoop: %s", p, err)
	}
	if err := oprot.WriteBool(bool(p.IncludeHadoop)); err != nil {
		return fmt.Errorf("%T.include_hadoop (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:include_hadoop: %s", p, err)
	}
	return err
}

func (p *GetDefaultConfigurationArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDefaultConfigurationArgs(%+v)", *p)
}

type GetDefaultConfigurationResult struct {
	Success []*ConfigVariable `thrift:"success,0" json:"success"`
}

func NewGetDefaultConfigurationResult() *GetDefaultConfigurationResult {
	return &GetDefaultConfigurationResult{}
}

var GetDefaultConfigurationResult_Success_DEFAULT []*ConfigVariable

func (p *GetDefaultConfigurationResult) GetSuccess() []*ConfigVariable {
	return p.Success
}
func (p *GetDefaultConfigurationResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetDefaultConfigurationResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetDefaultConfigurationResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ConfigVariable, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem29 := &ConfigVariable{}
		if err := _elem29.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem29, err)
		}
		p.Success = append(p.Success, _elem29)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetDefaultConfigurationResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_default_configuration_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetDefaultConfigurationResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetDefaultConfigurationResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetDefaultConfigurationResult(%+v)", *p)
}

type CloseArgs struct {
	Handle *QueryHandle `thrift:"handle,1" json:"handle"`
}

func NewCloseArgs() *CloseArgs {
	return &CloseArgs{}
}

var CloseArgs_Handle_DEFAULT *QueryHandle

func (p *CloseArgs) GetHandle() *QueryHandle {
	if !p.IsSetHandle() {
		return CloseArgs_Handle_DEFAULT
	}
	return p.Handle
}
func (p *CloseArgs) IsSetHandle() bool {
	return p.Handle != nil
}

func (p *CloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Handle = &QueryHandle{}
	if err := p.Handle.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Handle, err)
	}
	return nil
}

func (p *CloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("handle", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:handle: %s", p, err)
	}
	if err := p.Handle.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Handle, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:handle: %s", p, err)
	}
	return err
}

func (p *CloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseArgs(%+v)", *p)
}

type CloseResult struct {
	ErrorA1 *QueryNotFoundException `thrift:"error,1" json:"error"`
	Error2  *BeeswaxException       `thrift:"error2,2" json:"error2"`
}

func NewCloseResult() *CloseResult {
	return &CloseResult{}
}

var CloseResult_ErrorA1_DEFAULT *QueryNotFoundException

func (p *CloseResult) GetErrorA1() *QueryNotFoundException {
	if !p.IsSetErrorA1() {
		return CloseResult_ErrorA1_DEFAULT
	}
	return p.ErrorA1
}

var CloseResult_Error2_DEFAULT *BeeswaxException

func (p *CloseResult) GetError2() *BeeswaxException {
	if !p.IsSetError2() {
		return CloseResult_Error2_DEFAULT
	}
	return p.Error2
}
func (p *CloseResult) IsSetErrorA1() bool {
	return p.ErrorA1 != nil
}

func (p *CloseResult) IsSetError2() bool {
	return p.Error2 != nil
}

func (p *CloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CloseResult) ReadField1(iprot thrift.TProtocol) error {
	p.ErrorA1 = &QueryNotFoundException{}
	if err := p.ErrorA1.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.ErrorA1, err)
	}
	return nil
}

func (p *CloseResult) ReadField2(iprot thrift.TProtocol) error {
	p.Error2 = &BeeswaxException{
		SQLState: "     ",
	}
	if err := p.Error2.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Error2, err)
	}
	return nil
}

func (p *CloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("close_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetErrorA1() {
		if err := oprot.WriteFieldBegin("error", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:error: %s", p, err)
		}
		if err := p.ErrorA1.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.ErrorA1, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:error: %s", p, err)
		}
	}
	return err
}

func (p *CloseResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetError2() {
		if err := oprot.WriteFieldBegin("error2", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:error2: %s", p, err)
		}
		if err := p.Error2.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Error2, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:error2: %s", p, err)
		}
	}
	return err
}

func (p *CloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CloseResult(%+v)", *p)
}

type CleanArgs struct {
	LogContext LogContextId `thrift:"log_context,1" json:"log_context"`
}

func NewCleanArgs() *CleanArgs {
	return &CleanArgs{}
}

func (p *CleanArgs) GetLogContext() LogContextId {
	return p.LogContext
}
func (p *CleanArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CleanArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadString(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := LogContextId(v)
		p.LogContext = temp
	}
	return nil
}

func (p *CleanArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("clean_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CleanArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("log_context", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:log_context: %s", p, err)
	}
	if err := oprot.WriteString(string(p.LogContext)); err != nil {
		return fmt.Errorf("%T.log_context (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:log_context: %s", p, err)
	}
	return err
}

func (p *CleanArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CleanArgs(%+v)", *p)
}

type CleanResult struct {
}

func NewCleanResult() *CleanResult {
	return &CleanResult{}
}

func (p *CleanResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CleanResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("clean_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CleanResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CleanResult(%+v)", *p)
}
